

<section xml:id="ch08_05_t_n_applications">
  <title>Tangential And Normal Components</title>
  <objectives>
    <ul>
      <li>
        <p>
          Applications of multi-variable calculus (Tangential and Normal Components)
        </p>
      </li>
    </ul>
  </objectives>
  <introduction>
    <p>
      The unit tangent vector <m>\vec T</m> provides us with a unit vector in the direction of motion. We can obtain the direction of motion from the velocity. If we stay on a straight course, then our acceleration is in the same direction as our motion, and would only cause us to speed up or slow down. We'll call this tangential acceleration.
    </p>

    <p>
      If we want to design a roller coaster, build an F15 fighter plane, send a satellite in orbit, or construct anything that doesn't move in a straight line, we need to understand how acceleration causes us to leave a straight path. We may still be speeding up or slowing down (tangential acceleration), but now we'll have a component that veers us off the straight path. We'll call this normal acceleration, it's orthogonal to the velocity.
    </p>

    <p>
      Back in the vector chapter, we practiced writing a force <m>\vec F</m> as the sum of the component parallel to a displacement <m>\vec d</m> and the component orthogonal to <m>\vec d</m>. We could write this as <m>\vec F = \vec F_{|| \text{ to } \vec d} + \vec F_{\perp \text{ to } \vec d}.</m> The parallel part came from a projection. The orthogonal part came from vector subtraction. If you've forgotten how to do this, please do this review exercise.
    </p>

    <project>
      <statement>
        <p>
          Consider the force vector <m>\vec F = (0,-10)</m>, and displacement vector <m>\vec (2,-1)</m>. Compute the projection of <m>\vec F</m> onto <m>\vec d</m>, and then write <m>\vec F</m> as the sum of a vector parallel to <m>\vec d</m> and a vector orthogonal to <m>\vec d</m>. 
        </p>
        <aside>
          <p> 
            This is a good time to look back over the projection section from Unit 1: <xref ref="prob_force_intro"></xref>
          </p>
        </aside>
      </statement>
      <solution>
        <p>
          The projection is <m>\proj_{\vec d}\vec F = \frac{10}{5}(2,-1) = (4,-2)</m>.  This is the parallel component <m>\vec F_{|| \text{ to } \vec d} =(4,-2)</m>.  To get the orthogonal component, we know that <m>\vec F = \vec F_{|| \text{ to } \vec d} + \vec F_{\perp \text{ to } \vec d}</m>. Vector subtraction gives
          <m>\vec F_{\perp \text{ to } \vec d} = \vec F -\vec F_{|| \text{ to } \vec d} = (0,-10)-(4,-2) = (-4,-8)</m>.
          We now write
          <me>
            \vec F = (4,-2) + (-4,-8).
          </me>.
        </p>
      </solution>
    </project>

    <p>
      If we throw a pebble from a 64 ft tall cliff, then we could parameterize the path after <m>t</m> seconds using <m>\vec r(t) = (3t,64-16t^2)</m>. The numbers below get rather large in a hurry, so let's use a simpler parameterization to gain understanding about the connection between <m>\vec v</m>, <m>\vec a</m>, <m>\vec T</m>, and <m>\vec N</m>. Sometimes the key to understanding is to simplify the exercise.
    </p>

    <exploration>
      <introduction>
        <p>
          Consider the parameterization <m>\vec r(t) = (t,9-t^2)</m> (it's a simplified version of tossing a pebble off a building). Our goal, at time <m>t=1</m>, is to write <m>\vec a</m> in the form <m>\vec a = a_T\vec T+a_N\vec N.</m> Follow the steps below.
        </p>
      </introduction>
      <task>
        <p>
          Compute <m>\vec v</m>, <m>\vec a</m>, and <m>\vec T</m> at time <m>t</m>, and then at time <m>t=1</m>.
        </p>
      </task>
      <task>
        <p>
          At <m>t=1</m>, compute the projection of <m>\vec a</m> onto <m>\vec T</m>, i.e. compute <m>\proj_{\vec T(1)}\vec a(1)</m>.
        </p>
      </task>
      <task>
        <p>
          State <m>\vec N(t)</m> (remember you can flip the order and change a sign), and then at <m>t=1</m> compute <m>\text{ proj } _{\vec N(1)}\vec a(1)</m>.
        </p>
      </task>
      <task>
        <p>
          If we write <m>\vec a = a_T\vec T +a_N\vec N</m>, then what are <m>a_T</m> and <m>a_N</m>?
        </p>
      </task>
    </exploration>

    <definition>
      <title>Tangential and Normal Components of Acceleration</title>
      <statement>
        <p>
          Suppose that <m>\vec r(t)</m> is a smooth parametrization of a moving object. Let <m>\vec T</m> be the unit tangent vector. The tangential component of acceleration and the normal component of acceleration are the scalars <m>a_T</m> and <m>a_N</m> that we obtain by writing the acceleration as the sum of a vector parallel to <m>T</m> and a vector orthogonal to <m>\vec T</m>, i.e. the scalars that satisfy
          <me>
            \vec a = a_T\vec T+a_N\vec N.
          </me>
        </p>
      </statement>
    </definition>
  </introduction>

  <subsection>
    <title>Exploring Tangential and Normal Components of Acceleration</title>

    <p>
      Let's return to the example of Sammy on a merry-go-round. From this example, we'll see one of the key ideas in this section.
    </p>

    <exploration>
      <title>Optional</title>
      <introduction>
        <p>
          Suppose that Sammy sits <m>\rho</m> feet away from the center of the merry-go-ground. His sister decides to spin him around at different speeds. Let <m>\vec r(t) = (\rho \cos \omega t, \rho \sin \omega t)</m> be a parametrization of Sammy's postion.
        </p>
      </introduction>
      <task>
        <p>
          Show that Sammy's speed is <m>|\vec v|=\rho \omega</m>.
        </p>
      </task>
      <task>
        <p>
          Find the curvature of Sammy's path at any time <m>t</m> (it happens to be constant - and we did this already when we computed the curvature along a circle).
        </p>
      </task>
      <task>
        <p>
          Find the acceleration vector, and show that <m>\ds |\vec a| = \kappa |\vec v|^2 = \frac{|\vec v|^2}{\rho}</m>.
        </p>
      </task>
    </exploration>

    <p>
      In the exercise above, all of the acceleration is in the normal direction. The interesting thing to note is that the normal acceleration is ALWAY <m>a_N =  \frac{|\vec v|^2}{\rho}=\kappa |\vec v|^2</m>. That's what we'll now show.
      We'll show that the acceleration of an object moving along a curve <m>\vec r(t)</m> with velocity <m>\vec v(t)</m> is the sum
      <me>
        \vec a(t) = a_T\vec T+a_N\vec N=\frac{d}{dt}|\vec v(t)| \vec T + \kappa |\vec v|^2 \vec N.
      </me>
    </p>

    <p>
      The scalars <m>a_T=\dfrac{d}{dt}|\vec v(t)|</m> and <m>a_N=\kappa |\vec v|^2</m> are the tangential and normal components of acceleration. All we have to do is write the vector <m>\vec a(t)</m> as the sum of a vector parallel to <m>\vec T</m> and a vector orthogonal to <m>\vec T</m>.
    </p>

    <aside>
      <p>
        Engineers often use the equivalent formula <m>a_N = \frac{|\vec v|^2}{\rho}</m>, as <m>\rho</m> is a physical distance that they can measure.
      </p>
    </aside>

    <p>
      Before we decompose the acceleration into its tangential and normal components, let's look at two examples to see what these facts physically represent.
    </p>

    <exploration>
      <introduction>
        <p>
          Imagine that you are riding as a passenger on a road and encounter a series of switchbacks (so the road starts to zigzag up the mountain). Right before each bend in the road, you see a yellow sign that tells you a U-turn is coming up, and that you should reduce your speed from 45 mi/hr to 15 mi/hr. Assume the largest curvature along the turn is <m>\kappa</m>. Recall that <m>a_N=\kappa |\vec v|^2</m>. The engineers of the road designed the road so that if you are moving at 15 mi/hr, then the normal acceleration will be at most <m>A</m> units.
        </p>
      </introduction>
      <task>
        <statement>
          <p>
            Suppose that your driver (Ben) ignores the suggestion to slow down to 15 mi/hr.  He keeps going 45 mi/hr through the turn. Had he slowed down, the max acceleration would be <m>A</m>.  You're traveling 3 times faster than suggested.  What will your maximum normal acceleration be?
          </p>
        </statement>
        <hint>
          <p>
            It's more than <m>3A</m>.
          </p>
        </hint>
      </task>
      <task>
        <p>
          You yell at Ben to slow down (you don't want to die). So Ben decides to only slow to 30 mi/hr. He figures this means you'll only feel twice as much acceleration as <m>A</m>.  Explain why this line of reasoning is flawed.
        </p>
      </task>
      <task>
        <p>
          Ben gets frustrated by the fact that he has to slow down. He complains about the engineers who designed the road, and says, <q>they should have just built a larger corner so I could keep going 45.</q>  How much larger should the radius of the circle be so that you can travel 45 mi/hr instead of 15 mi/hr, and still feel the same acceleration <m>A</m>?
        </p>
      </task>
      <task>
        <p>
          Which will cause the normal acceleration to decrease more, halving your speed or halving the curvature (doubling the radius)?
        </p>
      </task>
    </exploration>

    <exploration>
      <introduction>
        <p>
          Prove that <m>\ds \vec a(t) = a_T\vec T+a_N\vec N=\frac{d}{dt}|\vec v| \vec T + \kappa |\vec v|^2 \vec N.</m> Here's some hints.
        </p>

        <aside>
          <p>
            Watch a <url href="http://www.youtube.com/watch?v=cSh2Bdd-yTg&amp;feature=bf_next&amp;list=PL30EE81142B1ED1F0&amp;lf=plpp_video">YouTube Video</url>.
          </p>
        </aside>
      </introduction>
      <task>
        <p>
          Rewrite the velocity <m>\vec v</m> as a magnitude <m>|\vec v|</m> times a direction <m>\vec T</m>, so <m>\vec v = |v|\vec T</m>.
        </p>
      </task>
      <task>
        <p>
          We know that <m>\vec a(t) = \frac{d}{dt}\vec v(t)</m>. Take the derivative of <m>\vec v = |\vec v|\vec T</m> by using the product rule (on the scalar product <m>|\vec v|\vec T</m>).
        </p>
      </task>
      <task>
        <p>
          You should encounter the quantity <m>d\vec T/dt</m>. We know that <m>\frac{d\vec T}{dt} = |\vec v|\frac{d\vec T}{ds}</m>. Why does <m>\ds d\vec T/dt=|\vec v|\kappa\vec N</m>?
        </p>
      </task>
      <task>
        <p>
          Conclude to explain why <m>a_N =\kappa |\vec v|^2</m>.
        </p>
      </task>
    </exploration>

    <p>
      Let's now use the fact above to get an extremely useful formula for the curvature.
    </p>

    <exploration>
      <statement>
        <p>
          Show that
          <me>
            \kappa = \frac{|\vec v\times \vec a|}{|\vec v|^3} = \frac{|\vec r'\times \vec r''|}{|\vec r'|^3}.
          </me>
        </p>
      </statement>
      <hint>
        <p>
          We know that <m>\ds \vec a = a_T\vec T+a_N\vec N=\frac{d}{dt}|\vec v| \vec T + \kappa |\vec v|^2 \vec N.</m>
          Cross both sides with <m>\vec v</m>. You should be able to cancel <m>\vec v\times \vec v</m> (why). Then take the magnitude of each side and solve for <m>\kappa</m>. You'll have to explain why <m>|\vec v\times \vec N| = |\vec v|</m>.
        </p>
      </hint>
    </exploration>

    <p>
      We can use the above formula for curvature to get a quick way to compute the curvature of a function <m>y=f(x)</m>. If you use the previous exercise, this formula falls out almost instantly. You'd see this formula in dynamics. This is the culminating idea from this chapter that you'll use again and again in engineering courses.
    </p>
    <aside>
      <p>
        And it shows up on the Fundamentals of Engineering exam (where you just have to use the formula, not prove where it comes from)!
      </p>
    </aside>

    <todo> See 13.4: 5</todo>
    <exploration xml:id="formula_for_curvature">
      <p>
        The function <m>y=f(x)</m> can be given the parametrization <m>\vec r(x) = (x,f(x))</m>. Use this parametrization (and the previous exercise) to show that the curvature is
        <me>
          \kappa(x) = \frac{|f''(x)|}{(1+(f')^2)^{3/2}},
        </me>
        and that the radius of curvature is
        <me>
          \rho(x) = \frac{(1+(f')^2)^{3/2}}{|f''(x)|}.
        </me>
      </p>
    </exploration>
  </subsection>

  <subsection>
    <title>Optional: Torsion</title>

    <aside>
      <p>
        We will be skipping this section, however, if you want to see more tie-in to physics and engineering, this skim this section.
      </p>
    </aside>

    <definition>
      <title>Torsion</title>
      <statement>
        <p>
          Let <m>\vec r(t)</m> be a parametrization of a smooth curve <m>C</m> with unit tangent vector <m>\vec T(t)</m>.
          The derivative of <m>\vec B</m> with respect to <m>s</m> tells us how rapidly the plane containing <m>\vec T</m> and <m>\vec N</m> rotates. We'll define the torsion vector to be
          
          <me>
            \vec \tau = \dfrac{d\vec B}{ds} = \dfrac{d\vec B/dt}{ds/dt}=\dfrac{d\vec B/dt}{|d\vec r/dt|}.
          </me>
        </p>
        <p>
          The torsion <m>\tau</m>, up to a sign, is the length of this vector. We say there is positive torsion if <m>\vec \tau</m> causes a counterclockwise rotation about <m>\vec T</m> (as you look down <m>\vec T</m>), which occurs precisely when <m>\vec tau</m> and <m>\vec N</m> point in opposite directions. We can summarize this is
          <me>
            \tau=\left|\dfrac{d\vec B}{ds}\right| \text{ or }  \tau=-\left|\dfrac{d\vec B}{ds}\right|,
          </me>
          where you choose <q><m>+</m></q> if <m>\vec N</m> and <m>\vec \tau</m> point in opposite directions.
        </p>
        <aside>
          <p> 
            Watch a <url href="http://www.youtube.com/watch?v=MVtUc2peJn0&amp;feature=bf_next&amp;list=PL30EE81142B1ED1F0&amp;lf=plpp_video">YouTube Video</url>.
          </p>
        </aside>
      </statement>
    </definition>

    <p>
      The computations involved in getting <m>\tau</m> require a lot of work. Let's use the computer to help us. You can do all of this with the aid of Sage. I'll let you decide from the code what <m>\tau</m> is. That will be your decision to make.
    </p>

    <exploration>
      <title>Optional</title>
      <p>
        Consider the helix <m>r(t)=(3\cos t, 3\sin t, 4t)</m>. In <xref ref="helix_example_of_T_N_and_B"/> we found
        <md>
          <mrow>\vec T \amp = (-\frac{3}{5}\sin t,\frac{3}{5}\cos t,\frac{4}{5})</mrow>
          <mrow>\vec N \amp = (-\cos t,-\sin t,0)</mrow>
          <mrow>\vec B \amp = (\frac{4}{5}\sin t,-\frac{4}{5}\cos t,\frac{3}{5})</mrow>
        </md>
      </p>

      <p>
        Compute the torsion vector <m>\vec \tau=\dfrac{d\vec B}{ds}</m>, and then give the torsion <m>\tau</m> (you'll need to determine the speed). Is the torsion positive or negative. Ask me in class to show you how you would be able to determine this physically (without any computations).
      </p>
    </exploration>

    <exploration>
      <title>Optional</title>
      <p>
        Consider the helix <m>r(t)=(4\sin t, 4\cos t, 3t)</m>. Use a computer to find <m>\vec T</m>, <m>\vec N</m>, <m>\vec B</m>, <m>\vec \kappa</m>, and <m>\vec \tau</m>. State your answers. Use your answers to then give <m>\kappa</m> and <m>\tau</m>. 
        <!-- (When you present on the board, just write down the 5 vectors, and then explain how you obtained <m>\kappa</m> and <m>\tau</m> from these vectors. If you follow the link, this is mostly already done for you. ) -->
      </p>
      <aside>
        <p>
          You can use <url href="\sageurlforcurvature">this sage link</url> or the SageMath Cell on the page.
        </p>
      </aside>
        <sage>
          <input>
            var('t')                 ##declare the variables you'll use below.
            r(t)=[(1*t),(1*t)^2]     ##Give a parametrization of the curve
            tBounds=(t,-2,2)         ##State the bounds you want in your plot
            point=1                  ##Give a t-value at which you would like to draw all vectors.

            ##Computation time
            v=diff(r,t)              #compute the velocity
            a=diff(v,t)              #compute the acceleration
            speed = v.norm()         #.norm() computes the length of a vector.
            T = v/speed              #compute the unit tangent vector
            dTdt = diff(T,t)         #compute dT/dt
            dTds = diff(T,t)/speed   #compute dT/ds (the curvatuve vector)
            curvature = dTds.norm()  #the curvatuve is the length of the curvatuve vector.
            N = dTdt/dTdt.norm()     #The unit normal vector

            ##Print the results.  I added .simplify_full().simplify_trig() to the end of each, so that the results will look simplified.
            pretty_print(table([
            [r"$\vec r$",r(t).simplify_full().simplify_trig()],
            [r"$\vec v$",v(t).simplify_full().simplify_trig()],
            [r"$\vec a$",a(t).simplify_full().simplify_trig()],
            [r"$\frac{ds}{dt} = |\vec v| = $ speed",speed(t).simplify_full().simplify_trig()],
            [r"$\vec T$",T(t).simplify_full().simplify_trig()],
            [r"$\frac{d\vec T}{dt}$",dTdt(t).simplify_full().simplify_trig()],
            [r"$\frac{d\vec T}{ds}$",dTds(t).simplify_full().simplify_trig()],
            [r"$\left|\frac{d\vec T}{ds}\right| = \kappa $",curvature(t).simplify_full().simplify_trig()],
            [r"$\vec N$",N(t).simplify_full().simplify_trig()],
            ]))


            ##Print the results.  I added .simplify_full().simplify_trig() to the end of each, so that the results will look simplified.
            print "At the time t = ",point, " we have the following:"
            pretty_print(table([
            [r"$\vec r$",r(point).simplify_full().simplify_trig()],
            [r"$\vec v$",v(point).simplify_full().simplify_trig()],
            [r"$\vec a$",a(point).simplify_full().simplify_trig()],
            [r"$\frac{ds}{dt} = |\vec v| = $ speed",speed(point).simplify_full().simplify_trig()],
            [r"$\vec T$",T(point).simplify_full().simplify_trig()],
            [r"$\frac{d\vec T}{dt}$",dTdt(point).simplify_full().simplify_trig()],
            [r"$\frac{d\vec T}{ds}$",dTds(point).simplify_full().simplify_trig()],
            [r"$\left|\frac{d\vec T}{ds}\right| = \kappa $",curvature(point).simplify_full().simplify_trig()],
            [r"$\vec N$",N(point).simplify_full().simplify_trig()],
            ]))

            ##Now let's make a graph
            p=parametric_plot(r,tBounds)                                        #this draws the curve
            p+=plot(vector(r(point)), width=4, color='gray')
            p+=plot(vector(v(point)), start=r(point), width=4, color='red')
            p+=plot(vector(a(point)), start=r(point), width=4, color='green')
            p+=plot(vector(T(point).simplify_full().simplify_trig()), start=r(point), width=4, color='black')
            p+=plot(vector(N(point).simplify_full().simplify_trig()), start=r(point), width=4, color='purple')
            p+=plot(vector(dTdt(point).simplify_full().simplify_trig()), start=r(point), width=4, color='yellow')
            p+=plot(vector(dTds(point).simplify_full().simplify_trig()), start=r(point), width=4, color='blue')

            print "Here's a plot of r, with the vectors v and a drawn at a point."
            print "gray-dashed = r, red = v, green = a, black = T, yellow = dT/dt, blue = dT/ds, purple=N"

            show(p)

            radiusOfCurvature=1/curvature(point)                    #compute the radius of curvature
            centerOfCurvature=r(point)+radiusOfCurvature*N(point)   #compute the center of curvature

            pretty_print(table([
            [r"$\rho$",radiusOfCurvature.simplify_full().simplify_trig()],
            [r"center of curvature", centerOfCurvature.simplify_full().simplify_trig()],
            ]))

            #Draw the circle of curvature on top of everything else.
            p+=parametric_plot(
                vector(centerOfCurvature.simplify_full().simplify_trig())
                +radiusOfCurvature.simplify_full().simplify_trig()
                *( vector(T(point).simplify_full().simplify_trig())*cos(t)
                  +vector(N(point).simplify_full().simplify_trig())*sin(t))
                ,(t,0,2*pi),color='gray')
            show(p)

            print "If you are in 3D, then this will compute B and dB/ds for you. Otherwise, you'll get a lot of errors."

            B=T.cross_product(N)
            dBds = B.diff(t)/speed

            pretty_print(table([
            [r"$N(t)$",B(t).simplify_full().simplify_trig()],
            [r"$B(t)$",B(t).simplify_full().simplify_trig()],
            [r"$\frac{d\vec B}{ds}(t)$", dBds(t).simplify_full().simplify_trig()],
            [r"$\left|\frac{d\vec B}{ds}(t)\right|$", dBds(t).norm().simplify_full().simplify_trig()],
            ["",r"Remember to compare $\vec N$ and $d\vec B/ds$ to determine torsion"],
            [r"$N(point)$",N(point).simplify_full().simplify_trig()],
            [r"$B(point)$",B(point).simplify_full().simplify_trig()],
            [r"$\frac{d\vec B}{ds}(point)$", dBds(point).simplify_full().simplify_trig()],
            [r"$\left|\frac{d\vec B}{ds}(point)\right|$", dBds(point).norm().simplify_full().simplify_trig()],
            ]))
          </input>
        </sage>
    </exploration>

    <p>
      In the examples above, you should have noticed that <m>\vec \tau</m> was either parallel to <m>\vec N</m> or anti-parallel to <m>\vec N</m>. Let's now show this is always the case. The key is to use the product rule on the cross product, together with some key fact about the cross product.
    </p>

    <project>
      <statement>
        <p>
          What is the cross product of <m>(1,2,3)</m> and <m>(2,4,6)</m>? If two vectors are parallel, then what is their cross product? In particular, what is the cross product of <m>\vec N</m> and <m>\vec \kappa</m>?
        </p>
      </statement>
      <solution>
        <p>
          The cross product of parallel vectors is always the zero vector <m>(0,0,0)</m>. This is because the area of the parallelogram formed using the parallel vectors is always zero. So all three answers are <m>(0,0,0)</m>.
        </p>
      </solution>
    </project>

    <exploration>
      <title>Optional</title>
      <introduction>
        <p>
          Suppose a curve <m>\vec r(t)</m> has the frame <m>\vec T(t)</m>, <m>\vec N(t)</m>, and <m>\vec B(t)</m>. Prove that <m>\dfrac{d\vec B}{ds}</m> is either parallel to <m>\vec N</m>, or points opposite <m>\vec N</m>. Here are some steps.
        </p>

        <aside>
          <p>
            Watch a <url href="http://www.youtube.com/watch?v=MVtUc2peJn0&amp;feature=bf_next&amp;list=PL30EE81142B1ED1F0&amp;lf=plpp_video">YouTube Video</url>.
          </p>
        </aside>
      </introduction>
      <task>
        <statement>
          <p>
            Why is <m>\dfrac{d\vec B}{ds}</m> orthogonal to <m>\vec B</m>?
          </p>
        </statement>
        <hint>
          <p>
            How long is <m>\vec B</m>? See <xref ref="vector_valued_functions_of_constant_length">Theorem</xref>.
          </p>
        </hint>
      </task>
      <task>
        <p>
          We know <m>\vec B=\vec T\times \vec N</m>. Compute the derivative of both sides using the product rule and explain why <m>\frac{d\vec T}{ds}\times \vec N</m> cancels out. Then explain why <m>\dfrac{d\vec B}{ds}</m> is orthogonal to <m>\vec T</m>.
        </p>
      </task>
      <task>
        <p>
          If <m>\dfrac{d\vec B}{ds}</m> is orthogonal to both <m>\vec B</m> and <m>\vec T</m> why must it be either parallel or anti-parallel to <m>\vec N</m>?
        </p>
      </task>
    </exploration>
  </subsection>
</section>

